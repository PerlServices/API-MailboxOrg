#!/usr/bin/env perl

=encoding utf-8

=cut

# PODNAME: get_mailbox_api.pl
# ABSTRACT: get API definitions from api.mailbox.org

use v5.24;

use Mojo::Base -strict, -signatures;

use Encode;
use List::Util qw(max);
use Mojo::File qw(path curfile);
use Mojo::JSON qw(decode_json encode_json);
use Mojo::UserAgent;
use Mojo::Util qw(dumper decamelize camelize class_to_path);
use Mojo::URL;
use Data::Printer;
use JSON::XS ();

my $ua   = Mojo::UserAgent->new;
my $base = 'https://api.mailbox.org/v1';

my $tx  = $ua->get( $base . '/doc/methods/index.html' );
my $dom = $tx->res->dom;

my $endpoints = $dom->find('#nav li a')->map( sub { 
    my $href = $_->attr('href');
    $href    =~ s{\A#}{}r;
} );

my %class_infos;
$endpoints->each( sub {
    my $method = $dom->find('a[name="' . $_ . '"] ~ div.method')->first;

    my $method_id             = $method->find('h2')->first->text;
    my ($class, $method_name) = $method_id =~ m{\A(.+)\.(.+)\z};

    if ( !$class ) {
        $class       = 'base';
        $method_name = $method_id;
    }

    $class   =~ s{\A.+\.}{}; 

    my $availability = $method->find('span[class*="lvl"]')->map( sub {
        $_->text;
    })->to_array;

    my $return = $method->find('> p > code')->first->text;

    my @params;
    my $param_table = $method->find('> table')->first;
    if ( $param_table ) {
        $param_table->find('> tr')->each( sub {
            my $cells = $_->find('td');

            return if !$cells || !$cells->[1];

            my $required = $cells->[0] && $cells->[0]->text ? 1 : 0;
            my $type;
            $type = $cells->[2]->find('>code')->first->text if $cells->[2];

            my %param_opts;
            if ( $cells->[3] ) {
                my $values_table = $cells->[3]->find('table')->first;

                if ( $values_table ) {
                    $values_table->find('tr')->each( sub {
                        my $values_cells = $_->find('td');

                        return if !$values_cells || !$values_cells->[1];

                        my $value = $values_cells->[0]->text;
                        return if $value eq 'Value';

                        push $param_opts{enum}->@*, $value;
                    });
                }
            }

            push @params, {
                name     => $cells->[1]->text,
                required => $required,
                type     => $type,
                %param_opts,
            };
        });
    }

    my %method_info = (
        desc      => $method->find('p.shortdesc')->first->text,
        available => $availability,
        command   => $method_id,
        returns   => lc( $return ),
        params    => \@params,
    );

    $class_infos{$class}->{$method_name} = \%method_info;
});

for my $class ( keys %class_infos ) {
    my $package = 'MailboxOrg::API::' . camelize $class;
    my $file    = class_to_path $package;

    say "Build class $package.pm";
    my $def = $class_infos{$class};

    my $code = _get_code( $class, $package, $class_infos{$class} );

    my $path = curfile->dirname->child(
        qw/.. lib API/, $file
    );

    $path->dirname->make_path;

    my $fh = $path->open('>');
    $fh->print( encode_utf8 $code );
    $fh->close;
}

sub _get_code ($class, $package, $class_infos) {
    my $subs        = '';
    my $validators  = '';
    my $methods_pod = '';
    my $sample_pod  = '';

    for my $sub_name ( sort keys $class_infos->%* ) {
        $validators  .= _get_validator( $sub_name, $class_infos->{$sub_name}, $class );
        $subs        .= _get_sub( $sub_name, $class_infos->{$sub_name}, $class );
        $methods_pod .= _get_pod( $sub_name, $class_infos->{$sub_name}, $class );
    }

    my $pod = sprintf q~
=head1 SYNOPSIS

    use API::MailboxOrg;

    my $user     = '1234abc';
    my $password = '1234abc';

    my $api      = API::MailboxOrg->new(
        user     => $user,
        password => $password,
    );

%s

=head1 METHODS

%s
~, $sample_pod, $methods_pod;

    my $code = sprintf q~package API::%s;

# ABSTRACT: %s

# ---
# This class is auto-generated by bin/get_mailbox_api.pl
# ---

use v5.24;

use strict;
use warnings;

use Moo;
use Types::Standard qw(Enum Str Int InstanceOf ArrayRef);
use API::MailboxOrg::Types qw(HashRefRestricted Boolean);
use Params::ValidationCompiler qw(validation_for);

extends 'API::MailboxOrg::APIBase';

with 'MooX::Singleton';

use feature 'signatures';
no warnings 'experimental::signatures';

# VERSION

my %%validators = (
%s
);

%s

1;

__END__

=pod

%s

~,
    $package, $package, $validators, $subs, $pod;

    return $code;
}

sub _get_validator ( $name, $info, $class ) {
    return '' if !$info->{params} || !$info->{params}->@*;

    if ( $name eq 'import' ) {
        $name = decamelize( $class ) . '_' . $name;
    }

    my @params_list = $info->{params}->@*;

    my $max_length = max map{ my $name = $_->{name}; length $name } @params_list;

    my $params = '';
    for my $param ( @params_list ) {
       my $p_name = $param->{name};

       my %map = (
           integer => 'Int',
           boolean => 'Boolean',
           string  => 'Str',
           array   => 'ArrayRef',
       );

       my $type = $map{ $param->{type} } || 'Str';

       if ( $param->{enum} && $param->{enum}->@* ) {
           my ($pre, $post) = $type eq 'ArrayRef' ? ( $type . '[', ']') : ('','');

           $type = sprintf "%sEnum[qw(%s)]%s", $pre, (join ' ', $param->{enum}->@*), $post;
       }

       my %restricted = (
           tarifflimits => 'plan',
       );

       if ( $restricted{ $p_name } ) {
           my ($base) = grep { $_->{name} eq $restricted{ $p_name } } @params_list;
           $type = sprintf 'HashRefRestricted[qw(%s)]', join ' ', $base->{enum}->@*;
       }

       $params .= sprintf "%s%s%s => { type => %s, optional => %s },\n",
           ' ' x 12,
           $p_name,
           ' ' x ( $max_length - length $p_name ),
           $type,
           ( $param->{required} ? 0 : 1 );
    }

    my $sub_validator = sprintf q~    '%s' => validation_for(
        params => {
%s
        },
    ),
~,
    $name, $params;

    return $sub_validator;
}

sub _get_sub ( $name, $info, $class ) {
    my $needs_auth = $info->{available} && $info->{available}->@*;

    if ( $name eq 'import' ) {
        $name = decamelize( $class ) . '_' . $name;
    }

    my $sub = sprintf q~
sub %s ($self, %%params) {
    my $validator = $validators{'%s'};
    %%params       = $validator->(%%params) if $validator;

    my %%opt = (%s);

    return $self->_request( '%s', \%%params, \%%opt );
}
~, $name, $name, ( $needs_auth ? 'needs_auth => 1' : '' ),  $info->{command};

    return $sub;
}

sub _get_pod ( $name, $info, $class ) {
    my $availability = '';

    if ( $name eq 'import' ) {
        $name = decamelize( $class ) . '_' . $name;
    }

    if ( $info->{available} && $info->{available}->@* ) {
        $availability = "\n\nAvailable for " . join ', ', $info->{available}->@*;
    }

    my $parameters = '';
    if ( $info->{params} && $info->{params}->@* ) {
        $parameters .= "\n\nParameters:\n\n=over 4\n\n";

        for my $param ( $info->{params}->@* ) {
            $parameters .= sprintf qq~=item * %s\n\n~, $param->{name};
        }

        $parameters .= "=back";
    }

    my $pod = sprintf q~

=head2 %s

%s%s%s

returns: %s

    $api->%s->%s(%%params);
~,
        $name, $info->{desc}, $availability, $parameters, $info->{returns}, $class, $name;

    return $pod;
}

